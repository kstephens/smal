
= SMAL - A (S)imple, (M)ark-sweep (AL)locator =

== Data Structure Overview ==

<code>smal_type</code> represents a user-data type of a fixed size, mark and free callbacks.

<code>smal_buffer</code> represents a <code>mmap()</code> region of <code>smal_buffer_size</code> aligned to <code>smal_buffer_size</code>.
Each <code>smal_buffer</code> is at the head of an <code>mmap()</code> region.

== Types ==

<code>smal_type</code> defines the size of objects and other characteristics that will be allocated from one or more <code>smal_buffer</code>s.
<code>mark_func</code> and <code>free_func</code> callback can be registered for each <code>smal_type</code>.

== Object Allocation ==

Objects are parceled, on-demand, from a <code>smal_buffer</code>, by incrementing <code>alloc_ptr</code> by a fixed object size, starting at <code>begin_ptr</code>
and terminating at <code>end_ptr</code>.
Objects that are returned to the <code>smal_buffer</code> are kept on its <code>free_list</code>.

== Memory Alignment ==

=== Benefits ===

The alignment restrictions of <code>smal_buffers</code> ensures very minimal mmap()/OS-level fragmentation.
It also allows for very fast pointer to <code>smal_buffer</code> mapping, making SMAL
suitable for conservative and non-conservative collection.

=== Issues ===

SMAL cannot service allocations large than <code>smal_buffer_size - sizeof(smal_buffer)</code>.

=== Characteristics ===

Every potential <code>smal_buffer*</code> maps to a "buffer_id".  A <code>smal_buffer</code>'s <code>buffer_id</code> is computed
by dividing the <code>smal_buffer</code> address by <code>smal_buffer_size</code>.

Since the <code>smal_buffer</code> header always resides at the aligned to <code>smal_buffer_size</code>, 
it's trivial to map a potential object ptr to a potential <code>smal_buffer*</code> or its <code>buffer_id</code>.

A perfect hash table that maps <code>buffer_id</code>s to <code>smal_buffer*</code> is maintained.
A lack of an entry in this table, means that any potential
ptr mapping within the aligned <code>buffer_id</code> region does not come from an <code>mmap()</code>'ed <code>smal_buffer</code>.  

Because the table is guaranteed to be perfect and non-colliding, mapping arbitrary ptr to 
smal_buffers can be done in O(1) time using a divide (or shift), a modulo and a vector index.

If a <code>smal_buffer*</code> can be found for a potential ptr, the ptr must also be within the <code>smal_buffer</code>'s
[ <code>begin_ptr</code>, <code>alloc_ptr</code> ) region.

== Object Mark Bits ==

Each <code>smal_buffer</code> maintains a mark bitmap for each object parceled from it.
The mark bitmap is transient; it's allocated and freed on demand during <code>smal_collect()</code>.

A pointer's mark bitmap index is computed by dividing the difference between the ptr and its <code>smal_buffer*</code> with
the size of the objects (<code>element_size</code>) allocated from the <code>smal_buffer</code>.

== Object Marking Algorithms ==

The algorithms/data structures are as follows:

=== Mark a (potential) object ===

1) Map potential object ptr to a potential <code>smal_buffer*</code>.
2) Determine if object ptr within <code>smal_buffer</code> region where object allocations took place.
3) Determine if object ptr has proper alignment to the head of the object allocation.
4) Determine the mark bitmap offset.
5) If object is not already marked, 
5.1) mark the object and call the smal_type's mark function.

=== Sweep ==

1) For each <code>smal_buffer</code>
2) MORE HERE.

== Ecology ==

SMAL relies on <code>MAP_ANON</code> <code>mmap()</code>/<code>munmap()</code>.
SMAL relies on <code>malloc()</code>/<code>free()</code>, thus can co-exist with any other <code>mmap()</code>-based <code>malloc()</code>/<code>free()</code> library.

== Roots ==

The user must provide a <code>smal_mark_roots()</code> function.
This allows the user to configure support for different configurations:
* single-threaded
* multi-threaded
* conservative
* type-safe 
SMAL does provide a simple explicit <code>smal_roots</code> system.

== Threads ==

SMAL supports a tiny <code>smal_thread</code> abstraction around <code>pthreads</code>.
The <code>smal_roots</code> package will work in a pthread environment.

== TODO ==

* Support for weak references.
* Support for finalization.

