
= SMAL: A (S)imple, (M)ark-sweep (AL)locator. =
@
== Data Structure Overview ==

<code>smal_type</code> represents a user-data type of a fixed size, mark and free callbacks.

<code>smal_buffer</code> represents a <code>mmap()</code> region of <code>smal_buffer_size</code> aligned to <code>smal_buffer_size</code>.
Each <code>smal_buffer</code> is at the head of an <code>mmap()</code> region.

== Object Allocation ==

Objects are parcelled, on-demand, from a <code>smal_buffer</code>, by incrementing <code>alloc_ptr</code> by a fixed object size, starting at <code>begin_ptr</code>
and terminating at <code>end_ptr</code>.
Objects that are returned to the <code>smal_buffer</code> are kept on its <code>free_list</code>.

== Alignment Benefits ==

The alignment restrictions of <code>smal_buffers</code> ensures very minimal mmap()/OS-level fragmentation.
It also allows for very fast pointer to <code>smal_buffer</code> mapping, making SMAL
suitable for conservative and non-conservative collection.

== Alignment Issues ==

SMAL cannot service allocations large than <code>smal_buffer_size - sizeof(smal_buffer)</code>.

== Alignment Characteristics ==

Every potental <code>smal_buffer*</code> maps to a "buffer_id".  A <code>smal_buffer</code>'s <code>buffer_id</code> is computed
by dividing the <code>smal_buffer</code> address by <code>smal_buffer_size</code>.

Since the <code>smal_buffer</code> header always resides at the aligned to <code>smal_buffer_size</code>, 
it's trivial to map a potential object ptr to a potential <code>smal_buffer*</code> or its <code>buffer_id</code>.

A perfect hash table that maps <code>buffer_id</code>s to <code>smal_buffer*</code> is maintained.
A lack of an entry in this table, means that any potential
ptr mapping within the aligned <code>buffer_id</code> region does not come from an <code>mmap()</code>'ed <code>smal_buffer</code>.  

Because the table is guaranteed to be perfect and non-colliding, mapping arbitrary ptr to 
smal_buffers can be done in O(1) time using a divide (or shift), a modulo and a vector index.

If a <code>smal_buffer*</code> can be found for a potential ptr, the ptr must also be within the <code>smal_buffer</code>'s
[ <code>begin_ptr</code>, <code>alloc_ptr</code> ) region.

== Object Mark Bits ==

Each <code>smal_buffer</code> maintains a mark bitmap for each object parcelled from it.
The mark bitmap is transient; it's allocated and freed on demand during <code>smal_collect()</code>.

A pointer's mark bitmap index is computed by dividing the difference between the ptr and its <code>smal_buffer*</code> with
the size of the objects (<code>element_size</code>) allocated from the <code>smal_buffer</code>.

== Object Marking Algoritm ==

The algorithm/data structures are as follows:

To mark a (potential) object:

1) Map potential object ptr to a potential <code>smal_buffer*</code>.
2) Determine if object ptr within <code>smal_buffer</code> region where object allocations took place.
3) Determine if object ptr has proper alignment to the head of the object allocation.
4) Determine the mark bitmap offset.
5) If object is not already marked, 
5.1) mark the object and call the smal_type's mark function.

== Ecology ==

SMAL relies on <code>MAP_ANON</code> <code>mmap()</code>/<code>munmap()</code>.
SMAL relies on <code>malloc()</code>/<code>free()</code>, thus can co-exist with any other <code>mmap()</code>-based <code>malloc()</code>/<code>free()</code> library.


