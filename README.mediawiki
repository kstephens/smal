
= SMAL: A (S)imple, (M)ark-sweep (AL)locator. =
@
== Data Structure Overview ==

<code>smal_type</code> represents a user-data type of a fixed size, mark and free callbacks.

<code>smal_buffer</code> represents a <code>mmap()</code> region of <code>smal_buffer_size</code> aligned to <code>smal_buffer_size</code>.
Each <code>smal_buffer</code> is at the head of an <code>mmap()</code> region.

== Object Allocation ==

Objects are parcelled, on-demand, from a <code>smal_buffer</code>, by incrementing <code>alloc_ptr</code> by a fixed object size, starting at <code>begin_ptr</code>
and terminating at <code>end_ptr</code>.
Objects that are returned to the <code>smal_buffer</code> are kept on its <code>free_list</code>.

== Alignment Benefits ==

The alignment restrictions of <code>smal_buffers</code> ensures very minimal mmap()/OS-level fragmentation.
It also allows for very fast pointer to <code>smal_buffer</code> mapping, making SMAL
suitable for conservative and non-conservative collection.

== Alignment Issues ==

SMAL cannot service allocations large than <code>smal_buffer_size - sizeof(smal_buffer)</code>.

== Alignment Characteristics ==

Every potental <code>smal_buffer*</code> maps to a "buffer_id".  A <code>smal_buffer</code>'s <code>buffer_id</code> is computed
by dividing the <code>smal_buffer</code> address by <code>smal_buffer_size</code>.

Since the smal_buffer header always resides at the aligned start of smal_buffer_size, 
it's trivial to map a potential object ptr to a potential smal_buffer* or its buffer_id.

A perfect hash table that maps buffer ids to smal_buffer* is maintained.
A lack of an entry in this table, means that any potential
ptr mapping within the aligned buffer_id region does not come from an mmap()'ed smal_buffer.  

Because the table is guaranteed to be perfect and non-colliding, mapping arbitrary ptr to 
smal_buffers can be done in O(1) time using a divide (or shift), a modulo and a vector index.

If a smal_buffer* can be found for a potential ptr, the ptr must also be within the smal_buffer's
[ begin_ptr, alloc_ptr ) region.

== Object Mark Bits ==

Each smal_buffer maintains a mark bitmap for each object parcelled from it.
The mark bitmap is transient; it's allocated and freed on demand during smal_collect.

A pointer's mark bitmap index is computed by dividing the difference between the ptr and its smal_buffer* with
the size of the objects allocated from the smal_buffer.

== Object Marking Algoritm ==

The algorithm/data structures are as follows:

To mark a (potential) object:

1) Map potential object ptr to a potential smal_buffer *.
2) Determine if object ptr within smal_buffer region where object allocations took place.
3) Determine if object ptr has proper alignment to the head of the object allocation.
4) Determine the mark bitmap offset.
5) If object is not already marked, 
5.1) mark the object and call the smal_type's mark function.

== Ecology ==

SMAL relies on MAP_ANON mmap()/munmap().
SMAL relies on malloc()/free(), thus can co-exist with any other mmap()-based malloc()/free() library.


